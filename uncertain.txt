-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Manipulating numbers with inherent experimental/measurement uncertainty.
--   
--   Provides tools to manipulate numbers tagged with inherent
--   experimental/measurement uncertainty, and propagates them through
--   functions based on principles from statistics.
--   
--   Create numbers:
--   
--   <pre>
--   7.13 +/- 0.05
--   91800 +/- 100
--   certain 7.9512
--   81.42 `withPrecision` 4
--   7    :: Uncertain Double
--   9.18 :: Uncertain Double
--   </pre>
--   
--   Apply functions and have the errors propagate properly:
--   
--   <pre>
--   &gt; let x = 1.52 +/- 0.07
--   &gt; let y = 781.4 +/- 0.3
--   &gt; let z = 1.53e-1 `withPrecision` 3
--   &gt; cosh x
--   2.4 +/- 0.2
--   &gt; exp x / z * sin (y ** z)
--   10.8 +/- 0.9
--   &gt; pi + 3 * logBase x y
--   50.87 +/- 2.e-2
--   </pre>
--   
--   Apply arbitrary numeric functions:
--   
--   <pre>
--   &gt; let f :: Double -&gt; Double -&gt; Double -&gt; Double;
--             f a b c = b ** exp (c / (2 * a))
--   &gt; y ** (exp z / (x * 2))
--   13.0 +/- 2.
--   &gt; uMap3 f x y z
--   13.0 +/- 2.
--   </pre>
--   
--   Note that this is very different from other libraries with similar
--   data types (like <tt>interval</tt> and <tt>rounded</tt>); these do not
--   attempt to maintain intervals or simply digit precisions; they instead
--   are intended to model actual experimental and measurement data with
--   their uncertainties, and apply functions to the data with the
--   uncertainties and properly propagating the errors with sound
--   statistical principles.
--   
--   As a clear example, take
--   
--   <pre>
--   &gt; (7 +/- 2) + (4 +/- 1)
--   11 +/- 2
--   </pre>
--   
--   In a library like <tt>interval</tt>, this would result in <tt>11 +/-
--   3</tt> (that is, a lower bound of 5 + 3 and an upper bound of 9 + 5).
--   However, with experimental data, two points of uncertainty 2 and 1
--   will add to create a new point of uncertainty 2 as well. (technically,
--   2.2)
@package uncertain
@version 0.1.0.0

module Data.Uncertain.Internal

-- | A data type representing a number with an associated
--   experimental/measurement uncertainty.
--   
--   So that you can treat it like a normal number, it is an instance of
--   <a>Num</a>, <a>Fractional</a>, <a>Floating</a>, and <a>Real</a>,
--   <a>RealFrac</a>, and <a>RealFloat</a>.
--   
--   You can apply any function or combination/composition of functions
--   from any of the above typeclasses.
--   
--   All typeclasses are fully defined, so go crazy! You should technically
--   be able to do anything you can possibly do with a generic instance of
--   <a>Num</a>, <a>Floating</a>, etc.
--   
--   Some instance notes:
--   
--   <ul>
--   <li>The <a>Show</a> instance displays the "normalized" value (see
--   <a>uNormalize</a>).</li>
--   <li>The <a>Eq</a> and <a>Ord</a> instances simply compare the
--   central/most likely values.</li>
--   <li>For <a>RealFrac</a> and <a>RealFloat</a> instances, most functions
--   are defined to be from the central value/most likely value. However,
--   <a>ceiling</a> and <a>floor</a> are taken to include the "entire
--   range":</li>
--   </ul>
--   
--   <pre>
--   &gt; ceiling (7.8 +/- 0.4)
--   9             -- as if calling `ceiling 8.2`
--   &gt; floor (14.1 +/- 0.3)
--   12            -- as if calling `floor 13.8`
--   </pre>
data Uncertain a
(:+-) :: !a -> !a -> Uncertain a

-- | <a>Normalize</a> an <a>Uncertain</a>.
--   
--   This means that the value can't have any more precision than implied
--   by the uncertainty, and that the uncertainty can't have more than one
--   digit of precision/significance.
--   
--   <pre>
--   &gt; uComponents $ uNormalize (15.235812734 +/- 0.0348513)
--   (15.23, 3.0e-2)
--   </pre>
--   
--   Note that the <a>Show</a> instance of <a>Uncertain</a> automatically
--   normalizes before showing.
--   
--   This is because, effectively, varying any of the digits that are
--   "normalized away" should yield an indistinguishable
--   <a>Uncertain</a>/experimental result.
--   
--   Has undefined behavior for "certain" values, with zero uncertainty.
uNormalize :: (RealFrac a, Floating a) => Uncertain a -> Uncertain a

-- | Wraps a <a>Num</a> in an <a>Uncertain</a>, associating it with an
--   uncertainty of <tt>0</tt>. Represents a number you know exactly, with
--   no uncertainty.
--   
--   This is also the default <a>fromInteger</a> method from the <a>Num</a>
--   instance.
--   
--   <pre>
--   &gt; certain 5 * certin 9
--   certain 45.0
--   &gt; (18.2 +/- 0.3) ** certain (1/2)
--   4.271 +/- 4.e-3
--   </pre>
--   
--   Usually, this can be ignored and only the actual literal needs be
--   entered.
--   
--   <pre>
--   &gt; 5 * 9 :: Uncertain Double
--   certain 45.0
--   &gt; (18.2 +/- 0.3) ** (1/2)
--   4.271 +/- 4.e-3
--   </pre>
--   
--   Use when you want an actual function.
--   
--   <pre>
--   &gt; map certain [1,2,3]
--   [certain 1.0, certain 2.0, certain 3.0]
--   </pre>
certain :: Num a => a -> Uncertain a

-- | Get the (central/most likely) value out of an <a>Uncertain</a>.
--   
--   <pre>
--   &gt; uVal (15.2 +/- 0.4)
--   15.2
--   </pre>
uVal :: Uncertain a -> a

-- | Get the uncertainty/root variance out of an <a>Uncertain</a>.
--   
--   <pre>
--   &gt; uVar (15.2 +/- 0.4)
--   0.4
--   </pre>
uVar :: Uncertain a -> a

-- | Returns the two components (the central value and the root variance)
--   of an <a>Uncertain</a>.
--   
--   <pre>
--   uComponents = uVal &amp;&amp;&amp; uVar
--   </pre>
uComponents :: Uncertain a -> (a, a)
instance Data.Data.Data a => Data.Data.Data (Data.Uncertain.Internal.Uncertain a)
instance (GHC.Show.Show a, GHC.Float.RealFloat a, GHC.Classes.Eq a) => GHC.Show.Show (Data.Uncertain.Internal.Uncertain a)
instance GHC.Float.Floating a => GHC.Num.Num (Data.Uncertain.Internal.Uncertain a)
instance GHC.Float.Floating a => GHC.Real.Fractional (Data.Uncertain.Internal.Uncertain a)
instance GHC.Float.Floating a => GHC.Float.Floating (Data.Uncertain.Internal.Uncertain a)
instance (GHC.Real.Real a, GHC.Real.Fractional a, GHC.Float.Floating a) => GHC.Real.Real (Data.Uncertain.Internal.Uncertain a)
instance (GHC.Float.Floating a, GHC.Real.RealFrac a) => GHC.Real.RealFrac (Data.Uncertain.Internal.Uncertain a)
instance GHC.Float.RealFloat a => GHC.Float.RealFloat (Data.Uncertain.Internal.Uncertain a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Uncertain.Internal.Uncertain a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Uncertain.Internal.Uncertain a)


-- | This module provides the <a>Uncertain</a> type constructor, which
--   represents a number with associated measurement/experimental
--   uncertainty. So that you can treat it like a normal number, it also
--   provides <a>Num</a>, <a>Fractional</a>, <a>Floating</a>, and
--   <a>Real</a>, <a>RealFrac</a>, and <a>RealFloat</a> instances, along
--   with all associated functions (<a>exp</a>, <a>**</a>, <a>sin</a>,
--   <a>/</a>, etc.), which properly propagate uncertainty with principles
--   from statistics.
--   
--   Because of this, all generic functions designed to work for all
--   <a>Num</a> (or <a>Floating</a>, <a>Real</a>, etc.) will work, and
--   propagate your uncertainty.
--   
--   You can directly construct these numbers with either <a>+/-</a> or
--   <a>certain</a>. <a>withPrecision</a> is also provided as a helper
--   function; you can also directly type numeric literals and the
--   <a>Num</a> and <a>Fractional</a> instances will automatically convert
--   them.
--   
--   <pre>
--   7.13 +/- 0.05
--   91800 +/- 100
--   certain 7.9512
--   81.42 `withPrecision` 4
--   7    :: Uncertain Double
--   9.18 :: Uncertain Double
--   </pre>
--   
--   Now you can do anything!
--   
--   <pre>
--   &gt; let x = 1.52 +/- 0.07
--   &gt; let y = 781.4 +/- 0.3
--   &gt; let z = 1.53e-1 `withPrecision` 3
--   &gt; cosh x
--   2.4 +/- 0.2
--   &gt; exp x / z * sin (y ** z)
--   10.8 +/- 0.9
--   &gt; pi + 3 * logBase x y
--   50.87 +/- 2.e-2
--   </pre>
--   
--   If you only have "normal" functions, like <tt>Double -&gt; Double
--   -&gt; Double</tt>, you can use <a>uMap</a>, <a>uMap2</a>, and
--   <a>uMap3</a>.
--   
--   <pre>
--   &gt; let f :: Double -&gt; Double -&gt; Double -&gt; Double;
--             f a b c = b ** exp (c / (2 * a))
--   &gt; y ** (exp z / (x * 2))
--   13.0 +/- 2.
--   &gt; uMap3 f x y z
--   13.0 +/- 2.
--   </pre>
--   
--   These use an epsilon of 0.001 to approximate the first partial
--   derivatives used in propagating the uncertainty. If your function
--   varies very rapidly at the points in question, you may adjust this as
--   needed using <a>uMap'</a>, <a>uMap2'</a>, and <a>uMap3'</a>, which
--   accept an <tt>epsilon</tt> parameter.
--   
--   <pre>
--   &gt; sin (2^10 * z)
--   -0.4 +/- 0.9
--   &gt; uMap (\a -&gt; sin (2^10 * a)) z
--   -0.4 +/- 0.8
--   &gt; uMap' 0.0001 (\a -&gt; sin (2^10 * a)) z
--   -0.4 +/- 0.9
--   </pre>
--   
--   There are also various utility functions to extract components out of
--   an <a>Uncertain</a>; also, to "normalize" them to remove "virtual
--   precision".
module Data.Uncertain

-- | A data type representing a number with an associated
--   experimental/measurement uncertainty.
--   
--   So that you can treat it like a normal number, it is an instance of
--   <a>Num</a>, <a>Fractional</a>, <a>Floating</a>, and <a>Real</a>,
--   <a>RealFrac</a>, and <a>RealFloat</a>.
--   
--   You can apply any function or combination/composition of functions
--   from any of the above typeclasses.
--   
--   All typeclasses are fully defined, so go crazy! You should technically
--   be able to do anything you can possibly do with a generic instance of
--   <a>Num</a>, <a>Floating</a>, etc.
--   
--   Some instance notes:
--   
--   <ul>
--   <li>The <a>Show</a> instance displays the "normalized" value (see
--   <a>uNormalize</a>).</li>
--   <li>The <a>Eq</a> and <a>Ord</a> instances simply compare the
--   central/most likely values.</li>
--   <li>For <a>RealFrac</a> and <a>RealFloat</a> instances, most functions
--   are defined to be from the central value/most likely value. However,
--   <a>ceiling</a> and <a>floor</a> are taken to include the "entire
--   range":</li>
--   </ul>
--   
--   <pre>
--   &gt; ceiling (7.8 +/- 0.4)
--   9             -- as if calling `ceiling 8.2`
--   &gt; floor (14.1 +/- 0.3)
--   12            -- as if calling `floor 13.8`
--   </pre>
data Uncertain a

-- | Wraps a <a>Num</a> in an <a>Uncertain</a>, associating it with an
--   uncertainty of <tt>0</tt>. Represents a number you know exactly, with
--   no uncertainty.
--   
--   This is also the default <a>fromInteger</a> method from the <a>Num</a>
--   instance.
--   
--   <pre>
--   &gt; certain 5 * certin 9
--   certain 45.0
--   &gt; (18.2 +/- 0.3) ** certain (1/2)
--   4.271 +/- 4.e-3
--   </pre>
--   
--   Usually, this can be ignored and only the actual literal needs be
--   entered.
--   
--   <pre>
--   &gt; 5 * 9 :: Uncertain Double
--   certain 45.0
--   &gt; (18.2 +/- 0.3) ** (1/2)
--   4.271 +/- 4.e-3
--   </pre>
--   
--   Use when you want an actual function.
--   
--   <pre>
--   &gt; map certain [1,2,3]
--   [certain 1.0, certain 2.0, certain 3.0]
--   </pre>
certain :: Num a => a -> Uncertain a

-- | Construct <a>Uncertain</a>s "by hand".
--   
--   <pre>
--   &gt; (7.18 +/- 0.03) * (2.3 +/- 0.7)
--   17.0 +/- 5.
--   </pre>
--   
--   Its main purpose is to make sure the uncertainties are reasonable and
--   positive.
(+/-) :: Num a => a -> a -> Uncertain a

-- | Given a number and a precision, provides an <a>Uncertain</a> with that
--   amount of precision, in decimal places.
--   
--   <pre>
--   &gt; 6.194 `withPrecision` 2
--   6.2 +/- 0.1
--   &gt; 84723 `withPrecision` 3
--   84700 +/- 100.
--   &gt; 7.2 `withPrecision` 5
--   7.2 +/- 1.e-4
--   </pre>
withPrecision :: (RealFrac a, Floating a) => a -> Int -> Uncertain a

-- | Get the (central/most likely) value out of an <a>Uncertain</a>.
--   
--   <pre>
--   &gt; uVal (15.2 +/- 0.4)
--   15.2
--   </pre>
uVal :: Uncertain a -> a

-- | Get the uncertainty/root variance out of an <a>Uncertain</a>.
--   
--   <pre>
--   &gt; uVar (15.2 +/- 0.4)
--   0.4
--   </pre>
uVar :: Uncertain a -> a

-- | Returns the two components (the central value and the root variance)
--   of an <a>Uncertain</a>.
--   
--   <pre>
--   uComponents = uVal &amp;&amp;&amp; uVar
--   </pre>
uComponents :: Uncertain a -> (a, a)

-- | <a>Normalize</a> an <a>Uncertain</a>.
--   
--   This means that the value can't have any more precision than implied
--   by the uncertainty, and that the uncertainty can't have more than one
--   digit of precision/significance.
--   
--   <pre>
--   &gt; uComponents $ uNormalize (15.235812734 +/- 0.0348513)
--   (15.23, 3.0e-2)
--   </pre>
--   
--   Note that the <a>Show</a> instance of <a>Uncertain</a> automatically
--   normalizes before showing.
--   
--   This is because, effectively, varying any of the digits that are
--   "normalized away" should yield an indistinguishable
--   <a>Uncertain</a>/experimental result.
--   
--   Has undefined behavior for "certain" values, with zero uncertainty.
uNormalize :: (RealFrac a, Floating a) => Uncertain a -> Uncertain a

-- | The "sum of repeated sampling":
--   
--   <pre>
--   n *~ x = sum (replicate n x)
--   </pre>
--   
--   See the <tt>Gotchas</tt> section for more information.
--   
--   Where <tt>n * x</tt> assumes you sampled <tt>x</tt> once and are
--   multiplying it by <tt>n</tt>, <tt>n *~ x</tt> assumes you are sampling
--   <tt>x</tt> <tt>n</tt> different times, with each time independently
--   varying.
--   
--   There is a flipped version, <a>~*</a>; the mnemonic is that the
--   <tt>~</tt> is on the side with the "uncertain" value.
--   
--   <a>~*</a> is to <a>*</a> as <a>^</a> is to <a>**</a>.
(*~) :: Floating a => Int -> Uncertain a -> Uncertain a

-- | The flipped version of <a>*~</a>. See documentation for <a>*~</a> and
--   the <tt>Gotchas</tt> section for more information.
--   
--   <pre>
--   x ~* n = sum (replicate n x)
--   </pre>
--   
--   The mnemonic is that the <tt>~</tt> is on the side with the
--   "uncertain" value.
--   
--   <a>~*</a> is to <a>*</a> as <a>^</a> is to <a>**</a>.
(~*) :: Floating a => Uncertain a -> Int -> Uncertain a

-- | Applies a given numerical function to an <a>Uncertain</a>.
--   
--   <pre>
--   &gt; let x = 5.1 +/- 0.2
--   &gt; sin x
--   -0.93 +/- 8.e-2
--   &gt; uMap sin x
--   -0.93 +/- 8.e-2
--   </pre>
uMap :: (Fractional a, Real a, Floating b) => (a -> b) -> Uncertain a -> Uncertain b

-- | Applies a given numerical function on two variables (of the same type)
--   to two <a>Uncertain</a>s.
--   
--   <pre>
--   &gt; let x = 5.1 +/- 0.2
--   &gt; let y = 194 +/- 7
--   &gt; (\x y -&gt; y / sin x) x y
--   -210.0 +/- 20.
--   &gt; uMap2 (\x y -&gt; y / sin x) x y
--   -210 +/- 20.
--   </pre>
uMap2 :: (Fractional a, Real a, Floating b) => (a -> a -> b) -> Uncertain a -> Uncertain a -> Uncertain b

-- | Applies a given numerical function on three variables (of the same
--   type) to three <a>Uncertain</a>s.
--   
--   <pre>
--   &gt; let x = 5.1 +/- 0.2
--   &gt; let y = 194 +/- 7
--   &gt; let z = 0.832 +/- 0.006
--   &gt; (\x y z -&gt; logBase z (abs (y / sin x))) x y z
--   -29.0 +/- 1.
--   &gt; uMap3 (\x y z -&gt; logBase z (y / sin x)) x y z
--   -29.0 +/- 1.
--   </pre>
uMap3 :: (Fractional a, Real a, Floating b) => (a -> a -> a -> b) -> Uncertain a -> Uncertain a -> Uncertain a -> Uncertain b

-- | Maps a given numerical function onto an <a>Uncertain</a>. Accepts an
--   <tt>epsilon</tt> parameter which determines the desired accuracy of
--   the first derivative approximation used in the determination of the
--   resulting uncertainty.
--   
--   <pre>
--   &gt; let x = 5.1 +/- 0.2
--   &gt; sin x
--   -0.93 +/- 8.e-2
--   &gt; uMap' 0.001 sin x
--   -0.93 +/- 8.e-2
--   &gt; uMap' 0.5 (** 3) x
--   -0.93 +/- 7.e-2
--   </pre>
--   
--   See <a>uMap</a>.
uMap' :: (Fractional a, Real a, Floating b) => a -> (a -> b) -> Uncertain a -> Uncertain b

-- | Applies a given numerical function on two variables of the same type
--   to two <a>Uncertain</a>s. Accepts an <tt>epsilon</tt> parameter, which
--   determines the desired accuracy of the first partial derivative
--   approximations used in the determination of the resulting uncertainty.
--   
--   <pre>
--   &gt; let x = 5.1 +/- 0.2
--   &gt; let y = 194 +/- 7
--   &gt; (\x y -&gt; y / sin x) x y
--   -210.0 +/- 20.
--   &gt; uMap2' 0.001 (\x y -&gt; y / sin x) x y
--   -210 +/- 20.
--   &gt; uMap2' 0.75 (\x y -&gt; y / sin x) x y
--   -210 +/- 80.
--   </pre>
--   
--   See <a>uMap2</a>.
uMap2' :: (Fractional a, Real a, Floating b) => a -> (a -> a -> b) -> Uncertain a -> Uncertain a -> Uncertain b

-- | Applies a given numerical function on three variables of the same type
--   to two <a>Uncertain</a>s. Accepts an <tt>epsilon</tt> parameter, which
--   determines the desired accuracy of the first partial derivative
--   approximations used in the determination of the resulting uncertainty.
--   
--   <pre>
--   &gt; let x = 5.1 +/- 0.2
--   &gt; let y = 194 +/- 7
--   &gt; let z = 0.832 +/- 0.006
--   &gt; (\x y z -&gt; logBase z (abs (y / sin x))) x y z
--   -29.0 +/- 1.
--   &gt; uMap3' 0.001 (\x y z -&gt; logBase z (y / sin x)) x y z
--   -29.0 +/- 1.
--   &gt; uMap3' 0.5 (\x y z -&gt; logBase z (y / sin x)) x y z
--   -29.1 +/- 0.5
--   </pre>
--   
--   See <a>uMap3</a>.
uMap3' :: (Fractional a, Real a, Floating b) => a -> (a -> a -> a -> b) -> Uncertain a -> Uncertain a -> Uncertain a -> Uncertain b

module Data.Uncertain.Correlated.Internal
data CVar b
CVPure :: b -> CVar b
CVKey :: Key -> CVar b
CVProp1 :: (Propagator1 b) -> (CVar b) -> CVar b
CVProp2 :: (Propagator2 b) -> (CVar b) -> (CVar b) -> CVar b
type Propagator1 a = (a, a) -> ((a, a), a)
type Propagator2 a = (a, a) -> (a, a) -> a -> ((a, a), a, a)
data CorrState b
CS :: Key -> IntMap b -> IntMap (IntMap b) -> CorrState b
[csCount] :: CorrState b -> Key
[csValMat] :: CorrState b -> IntMap b
[csVarMat] :: CorrState b -> IntMap (IntMap b)
emptyCorrState :: Num a => CorrState a
newtype Correlated b a
C :: State (CorrState b) a -> Correlated b a
[unCorrelated] :: Correlated b a -> State (CorrState b) a
fromUncertain :: Num b => Uncertain b -> Correlated b (CVar b)
instance GHC.Base.Monad (Data.Uncertain.Correlated.Internal.Correlated b)
instance GHC.Base.Applicative (Data.Uncertain.Correlated.Internal.Correlated b)
instance GHC.Base.Functor (Data.Uncertain.Correlated.Internal.Correlated b)
instance GHC.Show.Show a => GHC.Show.Show (Data.Uncertain.Correlated.Internal.CVar a)
instance GHC.Num.Num b => GHC.Num.Num (Data.Uncertain.Correlated.Internal.Correlated b (Data.Uncertain.Correlated.Internal.CVar b))
instance GHC.Num.Num b => GHC.Num.Num (Data.Uncertain.Correlated.Internal.CVar b)

module Data.Uncertain.Correlated
data CVar b
data Correlated b a
fromUncertain :: Num b => Uncertain b -> Correlated b (CVar b)
fromUncertain2 :: Num b => Uncertain b -> Uncertain b -> b -> Correlated b (CVar b, CVar b)
fromUncertain3 :: Num b => Uncertain b -> Uncertain b -> Uncertain b -> b -> b -> b -> Correlated b (CVar b, CVar b, CVar b)
marginalize :: Floating b => CVar b -> Correlated b (Uncertain b)
marginalize2 :: Floating b => CVar b -> CVar b -> Correlated b (Uncertain b, Uncertain b, b)
getCorrelation :: Floating b => CVar b -> CVar b -> Correlated b b
getCovariance :: Num b => CVar b -> CVar b -> Correlated b b
getCorrelated :: Floating b => Correlated b (CVar b) -> Uncertain b
getCorrelateds :: Floating b => Correlated b [CVar b] -> [Uncertain b]
getCorrelatedT :: (Floating b, Traversable f) => Correlated b (f (CVar b)) -> f (Uncertain b)
normalizeCVar :: Num b => CVar b -> Correlated b (CVar b)

module Data.Uncertain.Interactive
globalCorrState :: IORef (CorrState Double)
correlatedIO :: Correlated Double a -> IO a
evalCVar :: CVar Double -> IO (Uncertain Double)
evalCorrelation :: CVar Double -> CVar Double -> IO Double
evalCovariance :: CVar Double -> CVar Double -> IO Double
fromUncertainIO :: Uncertain Double -> IO (CVar Double)
fromUncertain2IO :: Uncertain Double -> Uncertain Double -> Double -> IO (CVar Double, CVar Double)
fromUncertain3IO :: Uncertain Double -> Uncertain Double -> Uncertain Double -> Double -> Double -> Double -> IO (CVar Double, CVar Double, CVar Double)
