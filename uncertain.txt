-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Manipulating numbers with inherent experimental/measurement uncertainty.
--   
--   Provides tools to manipulate numbers tagged with inherent
--   experimental/measurement uncertainty, and propagates them through
--   functions based on principles from statistics.
--   
--   Create numbers:
--   
--   <pre>
--   7.13 +/- 0.05
--   91800 +/- 100
--   certain 7.9512
--   81.42 `withPrecision` 4
--   7    :: Uncertain Double
--   9.18 :: Uncertain Double
--   </pre>
--   
--   Apply functions and have the errors propagate properly:
--   
--   <pre>
--   &gt; let x = 1.52 +/- 0.07
--   &gt; let y = 781.4 +/- 0.3
--   &gt; let z = 1.53e-1 `withPrecision` 3
--   &gt; cosh x
--   2.4 +/- 0.2
--   &gt; exp x / z * sin (y ** z)
--   10.8 +/- 0.9
--   &gt; pi + 3 * logBase x y
--   50.87 +/- 2.e-2
--   </pre>
--   
--   Apply arbitrary numeric functions:
--   
--   <pre>
--   &gt; let f :: Double -&gt; Double -&gt; Double -&gt; Double;
--             f a b c = b ** exp (c / (2 * a))
--   &gt; y ** (exp z / (x * 2))
--   13.0 +/- 2.
--   &gt; uMap3 f x y z
--   13.0 +/- 2.
--   </pre>
--   
--   Note that this is very different from other libraries with similar
--   data types (like <tt>interval</tt> and <tt>rounded</tt>); these do not
--   attempt to maintain intervals or simply digit precisions; they instead
--   are intended to model actual experimental and measurement data with
--   their uncertainties, and apply functions to the data with the
--   uncertainties and properly propagating the errors with sound
--   statistical principles.
--   
--   As a clear example, take
--   
--   <pre>
--   &gt; (7 +/- 2) + (4 +/- 1)
--   11 +/- 2
--   </pre>
--   
--   In a library like <tt>interval</tt>, this would result in <tt>11 +/-
--   3</tt> (that is, a lower bound of 5 + 3 and an upper bound of 9 + 5).
--   However, with experimental data, two points of uncertainty 2 and 1
--   will add to create a new point of uncertainty 2 as well. (technically,
--   2.2)
@package uncertain
@version 0.1.0.0

module Data.Hoples
data H2 a
H2 :: !a -> !a -> H2 a
data H3 a
H3 :: !a -> !a -> !a -> H3 a
data H4 a
H4 :: !a -> !a -> !a -> !a -> H4 a
data H5 a
H5 :: !a -> !a -> !a -> !a -> !a -> H5 a
instance Data.Traversable.Traversable Data.Hoples.H5
instance Data.Foldable.Foldable Data.Hoples.H5
instance GHC.Base.Functor Data.Hoples.H5
instance Data.Traversable.Traversable Data.Hoples.H4
instance Data.Foldable.Foldable Data.Hoples.H4
instance GHC.Base.Functor Data.Hoples.H4
instance Data.Traversable.Traversable Data.Hoples.H3
instance Data.Foldable.Foldable Data.Hoples.H3
instance GHC.Base.Functor Data.Hoples.H3
instance Data.Traversable.Traversable Data.Hoples.H2
instance Data.Foldable.Foldable Data.Hoples.H2
instance GHC.Base.Functor Data.Hoples.H2

module Data.Uncertain
data Uncert a
Un :: a -> a -> Uncert a
[uMean] :: Uncert a -> a

-- | maintained to be positive by only exporting the :+/- constructor
[uVar] :: Uncert a -> a
certain :: Num a => a -> Uncert a
(+/-) :: Num a => a -> a -> Uncert a
uStd :: Floating a => Uncert a -> a
asRange :: (Profunctor p, Functor f, Floating a) => p (a, a) (f (a, a)) -> p (Uncert a) (f (Uncert a))
withPrecisionAtBase :: (Floating a, RealFrac a) => Int -> a -> Int -> Uncert a
withPrecision :: (Floating a, RealFrac a) => a -> Int -> Uncert a
uNormalizeToBase :: (Floating a, RealFrac a) => Int -> Uncert a -> Uncert a
uNormalize :: (Floating a, RealFrac a) => Uncert a -> Uncert a
liftUF :: (Traversable f, Num a) => (forall s. Reifies s Tape => f (Reverse s a) -> Reverse s a) -> f (Uncert a) -> Uncert a
liftU :: Num a => (forall s. AD s (Forward a) -> AD s (Forward a)) -> Uncert a -> Uncert a
liftU2 :: Num a => (forall s. Reifies s Tape => Reverse s a -> Reverse s a -> Reverse s a) -> Uncert a -> Uncert a -> Uncert a
liftU3 :: Num a => (forall s. Reifies s Tape => Reverse s a -> Reverse s a -> Reverse s a -> Reverse s a) -> Uncert a -> Uncert a -> Uncert a -> Uncert a
liftU4 :: Num a => (forall s. Reifies s Tape => Reverse s a -> Reverse s a -> Reverse s a -> Reverse s a -> Reverse s a) -> Uncert a -> Uncert a -> Uncert a -> Uncert a -> Uncert a
liftU5 :: Num a => (forall s. Reifies s Tape => Reverse s a -> Reverse s a -> Reverse s a -> Reverse s a -> Reverse s a -> Reverse s a) -> Uncert a -> Uncert a -> Uncert a -> Uncert a -> Uncert a -> Uncert a
instance GHC.Generics.Selector Data.Uncertain.S1_0_1Uncert
instance GHC.Generics.Selector Data.Uncertain.S1_0_0Uncert
instance GHC.Generics.Constructor Data.Uncertain.C1_0Uncert
instance GHC.Generics.Datatype Data.Uncertain.D1Uncert
instance GHC.Generics.Generic1 Data.Uncertain.Uncert
instance GHC.Generics.Generic (Data.Uncertain.Uncert a)
instance Data.Data.Data a => Data.Data.Data (Data.Uncertain.Uncert a)
instance (GHC.Float.Floating a, GHC.Real.RealFrac a, GHC.Show.Show a) => GHC.Show.Show (Data.Uncertain.Uncert a)
instance GHC.Num.Num a => GHC.Num.Num (Data.Uncertain.Uncert a)
instance GHC.Real.Fractional a => GHC.Real.Fractional (Data.Uncertain.Uncert a)
instance GHC.Float.Floating a => GHC.Float.Floating (Data.Uncertain.Uncert a)
