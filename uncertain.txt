-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Manipulating numbers with inherent experimental/measurement uncertainty.
--   
--   Provides tools to manipulate numbers tagged with inherent
--   experimental/measurement uncertainty, and propagates them through
--   functions based on principles from statistics.
--   
--   Create numbers:
--   
--   <pre>
--   7.13 +/- 0.05
--   91800 +/- 100
--   certain 7.9512
--   81.42 `withPrecision` 4
--   7    :: Uncertain Double
--   9.18 :: Uncertain Double
--   </pre>
--   
--   Apply functions and have the errors propagate properly:
--   
--   <pre>
--   &gt; let x = 1.52 +/- 0.07
--   &gt; let y = 781.4 +/- 0.3
--   &gt; let z = 1.53e-1 `withPrecision` 3
--   &gt; cosh x
--   2.4 +/- 0.2
--   &gt; exp x / z * sin (y ** z)
--   10.8 +/- 0.9
--   &gt; pi + 3 * logBase x y
--   50.87 +/- 2.e-2
--   </pre>
--   
--   Apply arbitrary numeric functions:
--   
--   <pre>
--   &gt; let f :: Double -&gt; Double -&gt; Double -&gt; Double;
--             f a b c = b ** exp (c / (2 * a))
--   &gt; y ** (exp z / (x * 2))
--   13.0 +/- 2.
--   &gt; uMap3 f x y z
--   13.0 +/- 2.
--   </pre>
--   
--   Note that this is very different from other libraries with similar
--   data types (like <tt>interval</tt> and <tt>rounded</tt>); these do not
--   attempt to maintain intervals or simply digit precisions; they instead
--   are intended to model actual experimental and measurement data with
--   their uncertainties, and apply functions to the data with the
--   uncertainties and properly propagating the errors with sound
--   statistical principles.
--   
--   As a clear example, take
--   
--   <pre>
--   &gt; (7 +/- 2) + (4 +/- 1)
--   11 +/- 2
--   </pre>
--   
--   In a library like <tt>interval</tt>, this would result in <tt>11 +/-
--   3</tt> (that is, a lower bound of 5 + 3 and an upper bound of 9 + 5).
--   However, with experimental data, two points of uncertainty 2 and 1
--   will add to create a new point of uncertainty 2 as well. (technically,
--   2.2)
@package uncertain
@version 0.1.0.0

module Data.Hople
data H1 a
H1 :: !a -> H1 a
data H2 a
H2 :: !a -> !a -> H2 a
data H3 a
H3 :: !a -> !a -> !a -> H3 a
data H4 a
H4 :: !a -> !a -> !a -> !a -> H4 a
data H5 a
H5 :: !a -> !a -> !a -> !a -> !a -> H5 a
curryH1 :: (H1 a -> a) -> a -> a
curryH2 :: (H2 a -> a) -> a -> a -> a
curryH3 :: (H3 a -> a) -> a -> a -> a -> a
curryH4 :: (H4 a -> a) -> a -> a -> a -> a -> a
curryH5 :: (H5 a -> a) -> a -> a -> a -> a -> a -> a
uncurryH1 :: (a -> a) -> H1 a -> a
uncurryH2 :: (a -> a -> a) -> H2 a -> a
uncurryH3 :: (a -> a -> a -> a) -> H3 a -> a
uncurryH4 :: (a -> a -> a -> a -> a) -> H4 a -> a
uncurryH5 :: (a -> a -> a -> a -> a -> a) -> H5 a -> a
instance GHC.Show.Show a => GHC.Show.Show (Data.Hople.H5 a)
instance Data.Traversable.Traversable Data.Hople.H5
instance Data.Foldable.Foldable Data.Hople.H5
instance GHC.Base.Functor Data.Hople.H5
instance GHC.Show.Show a => GHC.Show.Show (Data.Hople.H4 a)
instance Data.Traversable.Traversable Data.Hople.H4
instance Data.Foldable.Foldable Data.Hople.H4
instance GHC.Base.Functor Data.Hople.H4
instance GHC.Show.Show a => GHC.Show.Show (Data.Hople.H3 a)
instance Data.Traversable.Traversable Data.Hople.H3
instance Data.Foldable.Foldable Data.Hople.H3
instance GHC.Base.Functor Data.Hople.H3
instance GHC.Show.Show a => GHC.Show.Show (Data.Hople.H2 a)
instance Data.Traversable.Traversable Data.Hople.H2
instance Data.Foldable.Foldable Data.Hople.H2
instance GHC.Base.Functor Data.Hople.H2
instance GHC.Show.Show a => GHC.Show.Show (Data.Hople.H1 a)
instance Data.Traversable.Traversable Data.Hople.H1
instance Data.Foldable.Foldable Data.Hople.H1
instance GHC.Base.Functor Data.Hople.H1


module Data.Uncertain

-- | Represents an independent experimental value centered around a mean
--   value with "inherent" and independent uncertainty.
--   
--   Mostly useful due to its instances of numeric typeclasses like
--   <a>Num</a>, <a>Fractional</a>, etc., which allows you to add and
--   multiply and apply arbitrary numerical functions to them and have the
--   uncertainty propagate appropriately. You can also lift arbitrary
--   (sufficiently polymorphic) functions with <a>liftU</a>, <a>liftUF</a>,
--   <a>liftU2</a> and family.
--   
--   Uncertaintly is properly propagated according to the second-degree
--   taylor series approximations of the applied functions. However, if the
--   higher-degree terms are large with respect to to the means and
--   variances of the uncertain values, these approximations may be
--   inaccurate.
--   
--   Can be created with <a>exact</a> to represent an "exact" measurement
--   with no uncertainty, <a>+/-</a> and <a>:+/-</a> to specify a standard
--   deviation as a range, <a>withPrecision</a> to specify through decimal
--   precision, and <a>withVar</a> to specify with a variance.
--   
--   Can be deconstructed with <a>:+/-</a>, the pattern
--   synonym/pseudo-constructor which matches on the mean and a standard
--   deviation. You can also access properties with <a>uMean</a>,
--   <a>uStd</a>, <a>uVar</a>, <a>uMeanStd</a>, <a>uMeanVar</a>,
--   <a>uRange</a>, etc.
--   
--   It's important to remember that each "occurrence" represents a unique
--   independent sample, so:
--   
--   <pre>
--   &gt; let x = 15 +/- 2 in x + x
--   30 +/- 3
--   
--   &gt; let x = 15 +/- 2 in x*2
--   30 +/- 4
--   </pre>
--   
--   <tt>x + x</tt> does not represent adding the same sample to itself
--   twice, it represents <i>independently</i> sampling two values within
--   the range <tt>15 +/- 2</tt> and adding them together. In general,
--   errors and deviations will cancel each-other out, leading to a smaller
--   uncertainty.
--   
--   However, <tt>x*2</tt> represents taking <i>one</i> sample and
--   multiplying it by two. This yields a greater uncertainty, because
--   errors and deviations are amplified.
--   
--   Also be aware that the <a>Show</a> instance "normalizes" the result,
--   and won't show any mean/central point to a decimal precision smaller
--   than the uncertainty, rounding off the excess.
data Uncert a

-- | Pattern match on an <a>Uncert</a> with its central value and its
--   standard deviation (see <a>uStd</a> for clarification).
--   
--   Can also be used to <i>construct</i> an <a>Uncert</a>, identically as
--   <a>+/-</a>.

-- | Create an <a>Uncert</a> around a central value and a given "range" of
--   uncertainty. The range is interpreted as the standard deviation of the
--   underlying random variable. Might be preferrable over <a>:+/-</a>
--   because it is more general (doesn't require a <a>Floating</a>
--   constraint) and looks a bit nicer.
--   
--   See <a>uStd</a> for more details.
(+/-) :: Num a => a -> a -> Uncert a

-- | Create an <a>Uncert</a> with an exact value and 0 uncertainty.
exact :: Num a => a -> Uncert a

-- | Create an <a>Uncert</a> about a given approximate central value, with
--   the given number of <i>digits of precision</i> (in decimal notation).
--   
--   <pre>
--   5.21 <a>withPrecision</a> 3 ≡ 5.21 <a>+/-</a> 0.01
--   </pre>
withPrecision :: (Floating a, RealFrac a) => a -> Int -> Uncert a

-- | Like <a>withPrecision</a>, except takes a number of "digits" of
--   precision in the desired numeric base. For example, in base 2, takes
--   the number of <i>bits</i> of precision.
--   
--   <pre>
--   <a>withPrecision</a> ≡ withPrecisionAtBase 10
--   </pre>
withPrecisionAtBase :: (Floating a, RealFrac a) => Int -> a -> Int -> Uncert a

-- | Create an <a>Uncert</a> around a central value, specifying its
--   uncertainty with a given <i>variance</i>. The variance is taken to be
--   proportional to the square of the range of uncertainty. See
--   <a>uStd</a> for more details.
--   
--   "Negative variances" are treated as positive.
withVar :: Num a => a -> a -> Uncert a

-- | Infer an <a>Uncert</a> from a given list of independent <i>samples</i>
--   of an underlying uncertain or random distribution.
fromSamples :: Fractional a => [a] -> Uncert a

-- | Get the mean<i>central value</i>expected value of an <a>Uncert</a>.
uMean :: Uncert a -> a

-- | Get the <i>variance</i> of the uncertainty of an <a>Uncert</a>,
--   proportional to the square of "how uncertain" a value is. Is the
--   square of <a>uStd</a>.
uVar :: Uncert a -> a

-- | Get the <i>standard deviation</i> of the uncertainty of an
--   <a>Uncert</a>, proportional to "how uncertain" a value is.
--   
--   Very informally, it can be thought of as the interval above and below
--   the mean that about 68% of sampled values will fall under after
--   repeated sampling, or as the range that one is 68% sure the true value
--   is within.
--   
--   Is the square root of <a>uVar</a>.
uStd :: Floating a => Uncert a -> a

-- | Retrieve both the mean (central) value and the underlying variance of
--   an <a>Uncert</a> together.
--   
--   <pre>
--   uMeanVar ≡ <a>uMean</a> &amp;&amp;&amp; <a>uVar</a>
--   </pre>
uMeanVar :: Uncert a -> (a, a)

-- | Retreve both the mean (central) value and the underlying standard
--   deviation of an <a>Uncert</a> together. (See <a>uStd</a> for more
--   details)
--   
--   <pre>
--   uMeanStd ≡ <a>uMean</a> &amp;&amp;&amp; <a>uStd</a>
--   </pre>
uMeanStd :: Floating a => Uncert a -> (a, a)

-- | Retrieve the "range" of the underlying distribution of an
--   <a>Uncert</a>, derived from the standard deviation, where which
--   approximly 68% of sampled values are expected to occur (or within
--   which you are 68% certain the true value is).
--   
--   <pre>
--   uRange (x +/- dx) ≡ (x - dx, x + dx)
--   </pre>
uRange :: Floating a => Uncert a -> (a, a)

-- | Lifts a numeric function over an <a>Uncert</a>. Correctly propagates
--   the uncertainty according to the second-order taylor expansion
--   expansion of the function. Note that if the higher-degree taylor
--   series terms are large with respect to the mean and variance, this
--   approximation may be inaccurate.
--   
--   Should take any function sufficiently polymorphic over numeric types,
--   so you can use things like <a>sqrt</a>, <a>sin</a>, <a>negate</a>,
--   etc.
--   
--   <pre>
--   ghci&gt; liftU (x -&gt; log x ^ 2) (12.2 +/- 0.5)
--   6.3 +/- 0.2
--   </pre>
liftU :: Fractional a => (forall s. AD s (Tower a) -> AD s (Tower a)) -> Uncert a -> Uncert a

-- | Lifts a multivariate numeric function on a container (given as an
--   <tt>f a -&gt; a</tt>) to work on a container of <a>Uncert</a>s.
--   Correctly propagates the uncertainty according to the second-order
--   (multivariate) taylor expansion of the function. Note that if the
--   higher-degree taylor series terms are large with respect to the means
--   and variances, this approximation may be inaccurate.
--   
--   Should take any function sufficiently polymorphic over numeric types,
--   so you can use things like <a>*</a>, <a>sqrt</a>, <a>atan2</a>, etc.
--   
--   <pre>
--   ghci&gt; liftUF ([x,y,z] -&gt; x*y+z) [12.2 +<i>- 0.5, 56 +</i>- 2, 0.12 +/- 0.08]
--   680 +/- 40
--   </pre>
liftUF :: (Traversable f, Fractional a) => (forall s. f (AD s (Sparse a)) -> AD s (Sparse a)) -> f (Uncert a) -> Uncert a

-- | Lifts a two-argument (curried) function over two <a>Uncert</a>s.
--   Correctly propagates the uncertainty according to the second-order
--   (multivariate) taylor expansion expansion of the function. Note that
--   if the higher-degree taylor series terms are large with respect to the
--   mean and variance, this approximation may be inaccurate.
--   
--   Should take any function sufficiently polymorphic over numeric types,
--   so you can use things like <a>*</a>, <a>atan2</a>, <a>**</a>, etc.
--   
--   <pre>
--   ghci&gt; liftU2 (x y -&gt; x**y) (13.5 +<i>- 0.1) (1.64 +</i>- 0.08)
--   70 +/- 10
--   </pre>
liftU2 :: Fractional a => (forall s. AD s (Sparse a) -> AD s (Sparse a) -> AD s (Sparse a)) -> Uncert a -> Uncert a -> Uncert a

-- | Lifts a three-argument (curried) function over three <a>Uncert</a>s.
--   See <a>liftU2</a> and <a>liftUF</a> for more details.
liftU3 :: Fractional a => (forall s. AD s (Sparse a) -> AD s (Sparse a) -> AD s (Sparse a) -> AD s (Sparse a)) -> Uncert a -> Uncert a -> Uncert a -> Uncert a

-- | Lifts a four-argument (curried) function over four <a>Uncert</a>s. See
--   <a>liftU2</a> and <a>liftUF</a> for more details.
liftU4 :: Fractional a => (forall s. AD s (Sparse a) -> AD s (Sparse a) -> AD s (Sparse a) -> AD s (Sparse a) -> AD s (Sparse a)) -> Uncert a -> Uncert a -> Uncert a -> Uncert a -> Uncert a

-- | Lifts a five-argument (curried) function over five <a>Uncert</a>s. See
--   <a>liftU2</a> and <a>liftUF</a> for more details.
liftU5 :: Fractional a => (forall s. AD s (Sparse a) -> AD s (Sparse a) -> AD s (Sparse a) -> AD s (Sparse a) -> AD s (Sparse a) -> AD s (Sparse a)) -> Uncert a -> Uncert a -> Uncert a -> Uncert a -> Uncert a -> Uncert a

-- | Attempts to "normalize" an <a>Uncert</a>. Rounds the uncertainty (the
--   standard deviation) to one digit of precision, and rounds the central
--   moment up to the implied precision.
--   
--   For example, it makes no real sense to have <tt>542.185433 +/-
--   83.584</tt>, because the extra digits of <tt>542.185433</tt> past the
--   tens place has no meaning because of the overpowering uncertainty.
--   Normalizing this results in <tt>540 +/- 80</tt>.
--   
--   Note that the <a>Show</a> instance for <a>Uncert</a> normalizes values
--   before showing them.
uNormalize :: (Floating a, RealFrac a) => Uncert a -> Uncert a

-- | Like <a>uNormalize</a>, but takes a numerical base to round with
--   respect to.
--   
--   <pre>
--   <a>uNormalize</a> ≡ uNormalizeAtBase 10
--   </pre>
uNormalizeAtBase :: (Floating a, RealFrac a) => Int -> Uncert a -> Uncert a

-- | Like <a>show</a> for <a>Uncert</a>, but does not normalize the value
--   (see <a>uNormalize</a>) before showing.
--   
--   <pre>
--   <a>show</a> ≡ uShow . <a>uNormalize</a>
--   </pre>
uShow :: (Show a, Floating a) => Uncert a -> String

-- | Like <a>showsPrec</a> for <a>Uncert</a>, but does not normalize the
--   value (see <a>uNormalize</a>) before showing. See documentation for
--   <a>showsPrec</a> for more information on how this is meant to be used.
uShowsPrec :: (Show a, Floating a) => Int -> Uncert a -> ShowS
instance GHC.Generics.Selector Data.Uncertain.S1_0_1Uncert
instance GHC.Generics.Selector Data.Uncertain.S1_0_0Uncert
instance GHC.Generics.Constructor Data.Uncertain.C1_0Uncert
instance GHC.Generics.Datatype Data.Uncertain.D1Uncert
instance GHC.Generics.Generic1 Data.Uncertain.Uncert
instance GHC.Generics.Generic (Data.Uncertain.Uncert a)
instance Data.Data.Data a => Data.Data.Data (Data.Uncertain.Uncert a)
instance (GHC.Show.Show a, GHC.Float.Floating a, GHC.Real.RealFrac a) => GHC.Show.Show (Data.Uncertain.Uncert a)
instance GHC.Real.Fractional a => GHC.Num.Num (Data.Uncertain.Uncert a)
instance GHC.Real.Fractional a => GHC.Real.Fractional (Data.Uncertain.Uncert a)
instance GHC.Float.Floating a => GHC.Float.Floating (Data.Uncertain.Uncert a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Uncertain.Uncert a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Uncertain.Uncert a)
instance (GHC.Real.Fractional a, GHC.Real.Real a) => GHC.Real.Real (Data.Uncertain.Uncert a)
instance GHC.Real.RealFrac a => GHC.Real.RealFrac (Data.Uncertain.Uncert a)
instance GHC.Float.RealFloat a => GHC.Float.RealFloat (Data.Uncertain.Uncert a)

module Data.Uncertain.Correlated.Internal
data CVar :: * -> * -> *
CK :: a -> CVar s a
CV :: Key -> CVar s a
CF :: (forall t. f (AD t (Sparse a)) -> AD t (Sparse a)) -> f (CVar s a) -> CVar s a
dephantom :: CVar s a -> CVar t a
data CorrF :: * -> * -> * -> *
Gen :: Uncert a -> (CVar s a -> b) -> CorrF s a b
Fun :: (forall t. f (AD t (Sparse a)) -> AD t (Sparse a)) -> f (CVar s a) -> (CVar s a -> b) -> CorrF s a b
Rei :: CVar s a -> (Uncert a -> b) -> CorrF s a b
newtype Corr s a b
Corr :: Free (CorrF s a) b -> Corr s a b
[corrFree] :: Corr s a b -> Free (CorrF s a) b
liftCF :: (Functor f, Fractional a) => (forall t. f (AD t (Sparse a)) -> AD t (Sparse a)) -> f (CVar s a) -> CVar s a
constC :: a -> CVar s a
liftC :: Fractional a => (forall t. AD t (Sparse a) -> AD t (Sparse a)) -> CVar s a -> CVar s a
liftC2 :: Fractional a => (forall t. AD t (Sparse a) -> AD t (Sparse a) -> AD t (Sparse a)) -> CVar s a -> CVar s a -> CVar s a
liftC3 :: Fractional a => (forall t. AD t (Sparse a) -> AD t (Sparse a) -> AD t (Sparse a) -> AD t (Sparse a)) -> CVar s a -> CVar s a -> CVar s a -> CVar s a
liftC4 :: Fractional a => (forall t. AD t (Sparse a) -> AD t (Sparse a) -> AD t (Sparse a) -> AD t (Sparse a) -> AD t (Sparse a)) -> CVar s a -> CVar s a -> CVar s a -> CVar s a -> CVar s a
liftC5 :: Fractional a => (forall t. AD t (Sparse a) -> AD t (Sparse a) -> AD t (Sparse a) -> AD t (Sparse a) -> AD t (Sparse a) -> AD t (Sparse a)) -> CVar s a -> CVar s a -> CVar s a -> CVar s a -> CVar s a -> CVar s a
corrToState :: (Monad m, Fractional a) => Corr s a b -> StateT (Key, IntMap (Uncert a)) m b
instance GHC.Base.Monad (Data.Uncertain.Correlated.Internal.Corr s a)
instance GHC.Base.Applicative (Data.Uncertain.Correlated.Internal.Corr s a)
instance GHC.Base.Functor (Data.Uncertain.Correlated.Internal.Corr s a)
instance GHC.Base.Functor (Data.Uncertain.Correlated.Internal.CorrF s a)
instance Control.Monad.Free.Class.MonadFree (Data.Uncertain.Correlated.Internal.CorrF s a) (Data.Uncertain.Correlated.Internal.Corr s a)
instance GHC.Real.Fractional a => GHC.Num.Num (Data.Uncertain.Correlated.Internal.CVar s a)
instance GHC.Real.Fractional a => GHC.Real.Fractional (Data.Uncertain.Correlated.Internal.CVar s a)
instance GHC.Float.Floating a => GHC.Float.Floating (Data.Uncertain.Correlated.Internal.CVar s a)


-- | Provides the <a>Corr</a> monad, which allows one to describe complex
--   relationships between random variables and evaluate their propagated
--   uncertainties <i>respecting</i> their inter-correlations.
--   
--   Fixes a basic "failure" of the <a>Uncert</a> type, which can't
--   describe correlated samples.
--   
--   For example, consider the difference between:
--   
--   <pre>
--   sum $ replicate 10 (12.5 +/- 0.8)   -- 125 +/- 3
--   10 * (12.5 +/- 0.8)                 -- 125 +/- 8
--   </pre>
--   
--   The first one represents the addition of ten independent samples,
--   whose errors will in general cancel eachother out. The second one
--   represents sampling once and multiplying it by ten, which will amplify
--   any error by a full factor of 10.
module Data.Uncertain.Correlated
data Corr s a b

-- | Evaluates the value described by a <a>Corr</a> monad, taking into
--   account inter-correlations between samples.
--   
--   Takes a universally qualified <a>Corr</a>, which should not affect
--   usage. See the examples in the documentation for <a>Corr</a>. The
--   univeral qualification is mostly a type system trick to ensure that
--   you aren't allowed to ever use <a>evalCorr</a> to evaluate a
--   <a>CVar</a>.
evalCorr :: Fractional a => (forall s. Corr s a b) -> b
data CVar :: * -> * -> *

-- | Generate a sample in <a>Corr</a> from an <a>Uncert</a> value.
sampleUncert :: Uncert a -> Corr s a (CVar s a)

-- | Generate an exact sample in <a>Corr</a> with zero uncertainty.
--   
--   Not super useful, since you can do something equivalent with
--   <a>constC</a> or the numeric instances:
--   
--   <pre>
--   sampleExact x  ≡ return (constC x)
--   sampleExact 10 ≡ return 10
--   </pre>
--   
--   But is provided for completeness alongside <a>sampleUncert</a>.
sampleExact :: a -> Corr s a (CVar s a)

-- | <a>Resolve</a> an <a>Uncert</a> from a <a>CVar</a> using its potential
--   multiple samples and sample sources, taking into account
--   inter-correlations between <a>CVar</a>s and samples.
--   
--   Note that if you use <a>sampleUncert</a> on the result, the new sample
--   will be treated as something completely independent. Usually this
--   should only be used as the "exit point" of a <a>Corr</a> description.
resolveUncert :: CVar s a -> Corr s a (Uncert a)
liftCF :: (Functor f, Fractional a) => (forall t. f (AD t (Sparse a)) -> AD t (Sparse a)) -> f (CVar s a) -> CVar s a
constC :: a -> CVar s a
liftC :: Fractional a => (forall t. AD t (Sparse a) -> AD t (Sparse a)) -> CVar s a -> CVar s a
liftC2 :: Fractional a => (forall t. AD t (Sparse a) -> AD t (Sparse a) -> AD t (Sparse a)) -> CVar s a -> CVar s a -> CVar s a
liftC3 :: Fractional a => (forall t. AD t (Sparse a) -> AD t (Sparse a) -> AD t (Sparse a) -> AD t (Sparse a)) -> CVar s a -> CVar s a -> CVar s a -> CVar s a
liftC4 :: Fractional a => (forall t. AD t (Sparse a) -> AD t (Sparse a) -> AD t (Sparse a) -> AD t (Sparse a) -> AD t (Sparse a)) -> CVar s a -> CVar s a -> CVar s a -> CVar s a -> CVar s a
liftC5 :: Fractional a => (forall t. AD t (Sparse a) -> AD t (Sparse a) -> AD t (Sparse a) -> AD t (Sparse a) -> AD t (Sparse a) -> AD t (Sparse a)) -> CVar s a -> CVar s a -> CVar s a -> CVar s a -> CVar s a -> CVar s a

module Data.Uncertain.MonteCarlo
liftUF :: (Traversable f, PrimMonad m) => (f Double -> Double) -> f (Uncert Double) -> Gen (PrimState m) -> m (Uncert Double)
liftU :: PrimMonad m => (Double -> Double) -> Uncert Double -> Gen (PrimState m) -> m (Uncert Double)
liftU2 :: PrimMonad m => (Double -> Double -> Double) -> Uncert Double -> Uncert Double -> Gen (PrimState m) -> m (Uncert Double)
liftU3 :: PrimMonad m => (Double -> Double -> Double -> Double) -> Uncert Double -> Uncert Double -> Uncert Double -> Gen (PrimState m) -> m (Uncert Double)
liftU4 :: PrimMonad m => (Double -> Double -> Double -> Double -> Double) -> Uncert Double -> Uncert Double -> Uncert Double -> Uncert Double -> Gen (PrimState m) -> m (Uncert Double)
liftU5 :: PrimMonad m => (Double -> Double -> Double -> Double -> Double -> Double) -> Uncert Double -> Uncert Double -> Uncert Double -> Uncert Double -> Uncert Double -> Gen (PrimState m) -> m (Uncert Double)
sampleUncert :: PrimMonad m => Uncert Double -> Gen (PrimState m) -> m Double

module Data.Uncertain.Correlated.Interactive
data CVar :: * -> * -> *
sampleUncert :: Uncert Double -> IO CVarIO
sampleExact :: Double -> IO CVarIO
resolveUncert :: CVarIO -> IO (Uncert Double)
liftCF :: (Functor f, Fractional a) => (forall t. f (AD t (Sparse a)) -> AD t (Sparse a)) -> f (CVar s a) -> CVar s a
constC :: a -> CVar s a
liftC :: Fractional a => (forall t. AD t (Sparse a) -> AD t (Sparse a)) -> CVar s a -> CVar s a
liftC2 :: Fractional a => (forall t. AD t (Sparse a) -> AD t (Sparse a) -> AD t (Sparse a)) -> CVar s a -> CVar s a -> CVar s a
liftC3 :: Fractional a => (forall t. AD t (Sparse a) -> AD t (Sparse a) -> AD t (Sparse a) -> AD t (Sparse a)) -> CVar s a -> CVar s a -> CVar s a -> CVar s a
liftC4 :: Fractional a => (forall t. AD t (Sparse a) -> AD t (Sparse a) -> AD t (Sparse a) -> AD t (Sparse a) -> AD t (Sparse a)) -> CVar s a -> CVar s a -> CVar s a -> CVar s a -> CVar s a
liftC5 :: Fractional a => (forall t. AD t (Sparse a) -> AD t (Sparse a) -> AD t (Sparse a) -> AD t (Sparse a) -> AD t (Sparse a) -> AD t (Sparse a)) -> CVar s a -> CVar s a -> CVar s a -> CVar s a -> CVar s a -> CVar s a
