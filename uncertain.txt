-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Manipulating numbers with inherent experimental/measurement uncertainty.
--   
--   Provides tools to manipulate numbers tagged with inherent
--   experimental/measurement uncertainty, and propagates them through
--   functions based on principles from statistics.
--   
--   Create numbers:
--   
--   <pre>
--   7.13 +/- 0.05
--   91800 +/- 100
--   certain 7.9512
--   81.42 `withPrecision` 4
--   7    :: Uncertain Double
--   9.18 :: Uncertain Double
--   </pre>
--   
--   Apply functions and have the errors propagate properly:
--   
--   <pre>
--   &gt; let x = 1.52 +/- 0.07
--   &gt; let y = 781.4 +/- 0.3
--   &gt; let z = 1.53e-1 `withPrecision` 3
--   &gt; cosh x
--   2.4 +/- 0.2
--   &gt; exp x / z * sin (y ** z)
--   10.8 +/- 0.9
--   &gt; pi + 3 * logBase x y
--   50.87 +/- 2.e-2
--   </pre>
--   
--   Apply arbitrary numeric functions:
--   
--   <pre>
--   &gt; let f :: Double -&gt; Double -&gt; Double -&gt; Double;
--             f a b c = b ** exp (c / (2 * a))
--   &gt; y ** (exp z / (x * 2))
--   13.0 +/- 2.
--   &gt; uMap3 f x y z
--   13.0 +/- 2.
--   </pre>
--   
--   Note that this is very different from other libraries with similar
--   data types (like <tt>interval</tt> and <tt>rounded</tt>); these do not
--   attempt to maintain intervals or simply digit precisions; they instead
--   are intended to model actual experimental and measurement data with
--   their uncertainties, and apply functions to the data with the
--   uncertainties and properly propagating the errors with sound
--   statistical principles.
--   
--   As a clear example, take
--   
--   <pre>
--   &gt; (7 +/- 2) + (4 +/- 1)
--   11 +/- 2
--   </pre>
--   
--   In a library like <tt>interval</tt>, this would result in <tt>11 +/-
--   3</tt> (that is, a lower bound of 5 + 3 and an upper bound of 9 + 5).
--   However, with experimental data, two points of uncertainty 2 and 1
--   will add to create a new point of uncertainty 2 as well. (technically,
--   2.2)
@package uncertain
@version 0.1.0.0

module Data.Hople
data H1 a
H1 :: !a -> H1 a
data H2 a
H2 :: !a -> !a -> H2 a
data H3 a
H3 :: !a -> !a -> !a -> H3 a
data H4 a
H4 :: !a -> !a -> !a -> !a -> H4 a
data H5 a
H5 :: !a -> !a -> !a -> !a -> !a -> H5 a
curryH1 :: (H1 a -> a) -> a -> a
curryH2 :: (H2 a -> a) -> a -> a -> a
curryH3 :: (H3 a -> a) -> a -> a -> a -> a
curryH4 :: (H4 a -> a) -> a -> a -> a -> a -> a
curryH5 :: (H5 a -> a) -> a -> a -> a -> a -> a -> a
uncurryH1 :: (a -> a) -> H1 a -> a
uncurryH2 :: (a -> a -> a) -> H2 a -> a
uncurryH3 :: (a -> a -> a -> a) -> H3 a -> a
uncurryH4 :: (a -> a -> a -> a -> a) -> H4 a -> a
uncurryH5 :: (a -> a -> a -> a -> a -> a) -> H5 a -> a
instance GHC.Show.Show a => GHC.Show.Show (Data.Hople.H5 a)
instance Data.Traversable.Traversable Data.Hople.H5
instance Data.Foldable.Foldable Data.Hople.H5
instance GHC.Base.Functor Data.Hople.H5
instance GHC.Show.Show a => GHC.Show.Show (Data.Hople.H4 a)
instance Data.Traversable.Traversable Data.Hople.H4
instance Data.Foldable.Foldable Data.Hople.H4
instance GHC.Base.Functor Data.Hople.H4
instance GHC.Show.Show a => GHC.Show.Show (Data.Hople.H3 a)
instance Data.Traversable.Traversable Data.Hople.H3
instance Data.Foldable.Foldable Data.Hople.H3
instance GHC.Base.Functor Data.Hople.H3
instance GHC.Show.Show a => GHC.Show.Show (Data.Hople.H2 a)
instance Data.Traversable.Traversable Data.Hople.H2
instance Data.Foldable.Foldable Data.Hople.H2
instance GHC.Base.Functor Data.Hople.H2
instance GHC.Show.Show a => GHC.Show.Show (Data.Hople.H1 a)
instance Data.Traversable.Traversable Data.Hople.H1
instance Data.Foldable.Foldable Data.Hople.H1
instance GHC.Base.Functor Data.Hople.H1

module Data.Uncertain

-- | Represents an independent experimental value centered around a mean
--   value with "inherent" and independent uncertainty.
--   
--   Mostly useful due to its instances of numeric typeclasses like
--   <a>Num</a>, <a>Fractional</a>, etc., which allows you to add and
--   multiply and apply arbitrary numerical functions to them and have the
--   uncertainty propagate appropriately.
--   
--   Can be created with <a>exact</a> to represent an "exact" measurement
--   with no uncertainty, <a>+/-</a> and <a>:+/-</a> to specify a standard
--   deviation as a range, <a>withPrecision</a> to specify through decimal
--   precision, and <a>withVar</a> to specify with a variance.
--   
--   Can be deconstructed with <a>:+/-</a>, the pattern
--   synonym/pseudo-constructor which matches on the mean and a standard
--   deviation. You can also access properties with <a>uMean</a>,
--   <a>uStd</a>, <a>uVar</a>, <a>uMeanStd</a>, <a>uMeanVar</a>,
--   <a>uRange</a>, etc.
--   
--   It's important to remember that each "occurrence" represents a unique
--   independent sample, so:
--   
--   <pre>
--   &gt; let x = 15 +/- 2 in x + x
--   30 +/- 3
--   
--   &gt; let x = 15 +/- 2 in x*2
--   30 +/- 4
--   </pre>
--   
--   <tt>x + x</tt> does not represent adding the same sample to itself
--   twice, it represents <i>independently</i> sampling two values within
--   the range <tt>15 +/- 2</tt> and adding them together. In general,
--   errors and deviations will cancel each-other out, leading to a smaller
--   uncertainty.
--   
--   However, <tt>x*2</tt> represents taking <i>one</i> sample and
--   multiplying it by two. This yields a greater uncertainty, because
--   errors and deviations are amplified.
--   
--   Also be aware that the <a>Show</a> instance "normalizes" the result,
--   and won't show any mean/central point to a decimal precision smaller
--   than the uncertainty, rounding off the excess.
data Uncert a
uMean :: Uncert a -> a
uVar :: Uncert a -> a
uStd :: Floating a => Uncert a -> a
uMeanVar :: Uncert a -> (a, a)
uMeanStd :: Floating a => Uncert a -> (a, a)
uRange :: Floating a => Uncert a -> (a, a)
(+/-) :: Num a => a -> a -> Uncert a
exact :: Num a => a -> Uncert a
withPrecisionAtBase :: (Floating a, RealFrac a) => Int -> a -> Int -> Uncert a
withPrecision :: (Floating a, RealFrac a) => a -> Int -> Uncert a
withVar :: Num a => a -> a -> Uncert a
fromSamples :: Fractional a => [a] -> Uncert a
uNormalizeAtBase :: (Floating a, RealFrac a) => Int -> Uncert a -> Uncert a
uNormalize :: (Floating a, RealFrac a) => Uncert a -> Uncert a
liftUF :: (Traversable f, Fractional a) => (forall s. f (AD s (Sparse a)) -> AD s (Sparse a)) -> f (Uncert a) -> Uncert a
liftU :: Fractional a => (forall s. AD s (Tower a) -> AD s (Tower a)) -> Uncert a -> Uncert a
liftU' :: Fractional a => (forall s. AD s (Sparse a) -> AD s (Sparse a)) -> Uncert a -> Uncert a
liftU2 :: Fractional a => (forall s. AD s (Sparse a) -> AD s (Sparse a) -> AD s (Sparse a)) -> Uncert a -> Uncert a -> Uncert a
liftU3 :: Fractional a => (forall s. AD s (Sparse a) -> AD s (Sparse a) -> AD s (Sparse a) -> AD s (Sparse a)) -> Uncert a -> Uncert a -> Uncert a -> Uncert a
liftU4 :: Fractional a => (forall s. AD s (Sparse a) -> AD s (Sparse a) -> AD s (Sparse a) -> AD s (Sparse a) -> AD s (Sparse a)) -> Uncert a -> Uncert a -> Uncert a -> Uncert a -> Uncert a
liftU5 :: Fractional a => (forall s. AD s (Sparse a) -> AD s (Sparse a) -> AD s (Sparse a) -> AD s (Sparse a) -> AD s (Sparse a) -> AD s (Sparse a)) -> Uncert a -> Uncert a -> Uncert a -> Uncert a -> Uncert a -> Uncert a
uShow :: (Show a, Floating a) => Uncert a -> String
uShowsPrec :: (Show a, Floating a) => Int -> Uncert a -> ShowS
instance GHC.Generics.Selector Data.Uncertain.S1_0_1Uncert
instance GHC.Generics.Selector Data.Uncertain.S1_0_0Uncert
instance GHC.Generics.Constructor Data.Uncertain.C1_0Uncert
instance GHC.Generics.Datatype Data.Uncertain.D1Uncert
instance GHC.Generics.Generic1 Data.Uncertain.Uncert
instance GHC.Generics.Generic (Data.Uncertain.Uncert a)
instance Data.Data.Data a => Data.Data.Data (Data.Uncertain.Uncert a)
instance (GHC.Show.Show a, GHC.Float.Floating a, GHC.Real.RealFrac a) => GHC.Show.Show (Data.Uncertain.Uncert a)
instance GHC.Real.Fractional a => GHC.Num.Num (Data.Uncertain.Uncert a)
instance GHC.Real.Fractional a => GHC.Real.Fractional (Data.Uncertain.Uncert a)
instance GHC.Float.Floating a => GHC.Float.Floating (Data.Uncertain.Uncert a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Uncertain.Uncert a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Uncertain.Uncert a)
instance (GHC.Real.Fractional a, GHC.Real.Real a) => GHC.Real.Real (Data.Uncertain.Uncert a)
instance GHC.Real.RealFrac a => GHC.Real.RealFrac (Data.Uncertain.Uncert a)
instance GHC.Float.RealFloat a => GHC.Float.RealFloat (Data.Uncertain.Uncert a)

module Data.Uncertain.Correlated
data CVar :: * -> * -> *
type Corr s a = Free (CorrF s a)
runCorr :: Fractional a => Corr s a b -> b
corrToState :: (Monad m, Fractional a) => Corr s a b -> StateT (Key, IntMap (Uncert a)) m b
sampleUncert :: Uncert a -> Corr s a (CVar s a)
sampleExact :: a -> Corr s a (CVar s a)
resolveUncert :: CVar s a -> Corr s a (Uncert a)
liftCF :: (Functor f, Fractional a) => (forall t. f (AD t (Sparse a)) -> AD t (Sparse a)) -> f (CVar s a) -> CVar s a
liftC :: Fractional a => (forall t. AD t (Sparse a) -> AD t (Sparse a)) -> CVar s a -> CVar s a
liftC2 :: Fractional a => (forall t. AD t (Sparse a) -> AD t (Sparse a) -> AD t (Sparse a)) -> CVar s a -> CVar s a -> CVar s a
liftC3 :: Fractional a => (forall t. AD t (Sparse a) -> AD t (Sparse a) -> AD t (Sparse a) -> AD t (Sparse a)) -> CVar s a -> CVar s a -> CVar s a -> CVar s a
liftC4 :: Fractional a => (forall t. AD t (Sparse a) -> AD t (Sparse a) -> AD t (Sparse a) -> AD t (Sparse a) -> AD t (Sparse a)) -> CVar s a -> CVar s a -> CVar s a -> CVar s a -> CVar s a
liftC5 :: Fractional a => (forall t. AD t (Sparse a) -> AD t (Sparse a) -> AD t (Sparse a) -> AD t (Sparse a) -> AD t (Sparse a) -> AD t (Sparse a)) -> CVar s a -> CVar s a -> CVar s a -> CVar s a -> CVar s a -> CVar s a
instance GHC.Base.Functor (Data.Uncertain.Correlated.CorrF s a)
instance GHC.Real.Fractional a => GHC.Num.Num (Data.Uncertain.Correlated.CVar s a)
instance GHC.Real.Fractional a => GHC.Real.Fractional (Data.Uncertain.Correlated.CVar s a)
instance GHC.Float.Floating a => GHC.Float.Floating (Data.Uncertain.Correlated.CVar s a)

module Data.Uncertain.MonteCarlo
liftU :: PrimMonad m => (Double -> Double) -> Uncert Double -> Gen (PrimState m) -> m (Uncert Double)
liftUF :: (Traversable f, PrimMonad m) => (f Double -> Double) -> f (Uncert Double) -> Gen (PrimState m) -> m (Uncert Double)
liftU2 :: PrimMonad m => (Double -> Double -> Double) -> Uncert Double -> Uncert Double -> Gen (PrimState m) -> m (Uncert Double)
liftU3 :: PrimMonad m => (Double -> Double -> Double -> Double) -> Uncert Double -> Uncert Double -> Uncert Double -> Gen (PrimState m) -> m (Uncert Double)
liftU4 :: PrimMonad m => (Double -> Double -> Double -> Double -> Double) -> Uncert Double -> Uncert Double -> Uncert Double -> Uncert Double -> Gen (PrimState m) -> m (Uncert Double)
liftU5 :: PrimMonad m => (Double -> Double -> Double -> Double -> Double -> Double) -> Uncert Double -> Uncert Double -> Uncert Double -> Uncert Double -> Uncert Double -> Gen (PrimState m) -> m (Uncert Double)
